// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: entry.proto

#ifndef PROTOBUF_entry_2eproto__INCLUDED
#define PROTOBUF_entry_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2003000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2003000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/generated_message_reflection.h>
// @@protoc_insertion_point(includes)

namespace cloudflare {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_entry_2eproto();
void protobuf_AssignDesc_entry_2eproto();
void protobuf_ShutdownFile_entry_2eproto();

class ZoneTimeBucket;
class ZoneTimeBucket_Counter;

// ===================================================================

class ZoneTimeBucket_Counter : public ::google::protobuf::Message {
 public:
  ZoneTimeBucket_Counter();
  virtual ~ZoneTimeBucket_Counter();
  
  ZoneTimeBucket_Counter(const ZoneTimeBucket_Counter& from);
  
  inline ZoneTimeBucket_Counter& operator=(const ZoneTimeBucket_Counter& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const ZoneTimeBucket_Counter& default_instance();
  
  void Swap(ZoneTimeBucket_Counter* other);
  
  // implements Message ----------------------------------------------
  
  ZoneTimeBucket_Counter* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ZoneTimeBucket_Counter& from);
  void MergeFrom(const ZoneTimeBucket_Counter& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required string key = 1;
  inline bool has_key() const;
  inline void clear_key();
  static const int kKeyFieldNumber = 1;
  inline const ::std::string& key() const;
  inline void set_key(const ::std::string& value);
  inline void set_key(const char* value);
  inline void set_key(const char* value, size_t size);
  inline ::std::string* mutable_key();
  
  // required int64 value = 2;
  inline bool has_value() const;
  inline void clear_value();
  static const int kValueFieldNumber = 2;
  inline ::google::protobuf::int64 value() const;
  inline void set_value(::google::protobuf::int64 value);
  
  // @@protoc_insertion_point(class_scope:cloudflare.ZoneTimeBucket.Counter)
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::std::string* key_;
  static const ::std::string _default_key_;
  ::google::protobuf::int64 value_;
  friend void  protobuf_AddDesc_entry_2eproto();
  friend void protobuf_AssignDesc_entry_2eproto();
  friend void protobuf_ShutdownFile_entry_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static ZoneTimeBucket_Counter* default_instance_;
};
// -------------------------------------------------------------------

class ZoneTimeBucket : public ::google::protobuf::Message {
 public:
  ZoneTimeBucket();
  virtual ~ZoneTimeBucket();
  
  ZoneTimeBucket(const ZoneTimeBucket& from);
  
  inline ZoneTimeBucket& operator=(const ZoneTimeBucket& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const ZoneTimeBucket& default_instance();
  
  void Swap(ZoneTimeBucket* other);
  
  // implements Message ----------------------------------------------
  
  ZoneTimeBucket* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ZoneTimeBucket& from);
  void MergeFrom(const ZoneTimeBucket& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  typedef ZoneTimeBucket_Counter Counter;
  
  // accessors -------------------------------------------------------
  
  // required string map_name = 1;
  inline bool has_map_name() const;
  inline void clear_map_name();
  static const int kMapNameFieldNumber = 1;
  inline const ::std::string& map_name() const;
  inline void set_map_name(const ::std::string& value);
  inline void set_map_name(const char* value);
  inline void set_map_name(const char* value, size_t size);
  inline ::std::string* mutable_map_name();
  
  // required string classification = 2;
  inline bool has_classification() const;
  inline void clear_classification();
  static const int kClassificationFieldNumber = 2;
  inline const ::std::string& classification() const;
  inline void set_classification(const ::std::string& value);
  inline void set_classification(const char* value);
  inline void set_classification(const char* value, size_t size);
  inline ::std::string* mutable_classification();
  
  // required string doctype = 3;
  inline bool has_doctype() const;
  inline void clear_doctype();
  static const int kDoctypeFieldNumber = 3;
  inline const ::std::string& doctype() const;
  inline void set_doctype(const ::std::string& value);
  inline void set_doctype(const char* value);
  inline void set_doctype(const char* value, size_t size);
  inline ::std::string* mutable_doctype();
  
  // required string pop = 4;
  inline bool has_pop() const;
  inline void clear_pop();
  static const int kPopFieldNumber = 4;
  inline const ::std::string& pop() const;
  inline void set_pop(const ::std::string& value);
  inline void set_pop(const char* value);
  inline void set_pop(const char* value, size_t size);
  inline ::std::string* mutable_pop();
  
  // required string psource = 5;
  inline bool has_psource() const;
  inline void clear_psource();
  static const int kPsourceFieldNumber = 5;
  inline const ::std::string& psource() const;
  inline void set_psource(const ::std::string& value);
  inline void set_psource(const char* value);
  inline void set_psource(const char* value, size_t size);
  inline ::std::string* mutable_psource();
  
  // required string result_id = 6;
  inline bool has_result_id() const;
  inline void clear_result_id();
  static const int kResultIdFieldNumber = 6;
  inline const ::std::string& result_id() const;
  inline void set_result_id(const ::std::string& value);
  inline void set_result_id(const char* value);
  inline void set_result_id(const char* value, size_t size);
  inline ::std::string* mutable_result_id();
  
  // required string db_key = 7;
  inline bool has_db_key() const;
  inline void clear_db_key();
  static const int kDbKeyFieldNumber = 7;
  inline const ::std::string& db_key() const;
  inline void set_db_key(const ::std::string& value);
  inline void set_db_key(const char* value);
  inline void set_db_key(const char* value, size_t size);
  inline ::std::string* mutable_db_key();
  
  // required string db_path = 8;
  inline bool has_db_path() const;
  inline void clear_db_path();
  static const int kDbPathFieldNumber = 8;
  inline const ::std::string& db_path() const;
  inline void set_db_path(const ::std::string& value);
  inline void set_db_path(const char* value);
  inline void set_db_path(const char* value, size_t size);
  inline ::std::string* mutable_db_path();
  
  // optional string kv_map_file = 9;
  inline bool has_kv_map_file() const;
  inline void clear_kv_map_file();
  static const int kKvMapFileFieldNumber = 9;
  inline const ::std::string& kv_map_file() const;
  inline void set_kv_map_file(const ::std::string& value);
  inline void set_kv_map_file(const char* value);
  inline void set_kv_map_file(const char* value, size_t size);
  inline ::std::string* mutable_kv_map_file();
  
  // repeated .cloudflare.ZoneTimeBucket.Counter map_entry = 10;
  inline int map_entry_size() const;
  inline void clear_map_entry();
  static const int kMapEntryFieldNumber = 10;
  inline const ::cloudflare::ZoneTimeBucket_Counter& map_entry(int index) const;
  inline ::cloudflare::ZoneTimeBucket_Counter* mutable_map_entry(int index);
  inline ::cloudflare::ZoneTimeBucket_Counter* add_map_entry();
  inline const ::google::protobuf::RepeatedPtrField< ::cloudflare::ZoneTimeBucket_Counter >&
      map_entry() const;
  inline ::google::protobuf::RepeatedPtrField< ::cloudflare::ZoneTimeBucket_Counter >*
      mutable_map_entry();
  
  // @@protoc_insertion_point(class_scope:cloudflare.ZoneTimeBucket)
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::std::string* map_name_;
  static const ::std::string _default_map_name_;
  ::std::string* classification_;
  static const ::std::string _default_classification_;
  ::std::string* doctype_;
  static const ::std::string _default_doctype_;
  ::std::string* pop_;
  static const ::std::string _default_pop_;
  ::std::string* psource_;
  static const ::std::string _default_psource_;
  ::std::string* result_id_;
  static const ::std::string _default_result_id_;
  ::std::string* db_key_;
  static const ::std::string _default_db_key_;
  ::std::string* db_path_;
  static const ::std::string _default_db_path_;
  ::std::string* kv_map_file_;
  static const ::std::string _default_kv_map_file_;
  ::google::protobuf::RepeatedPtrField< ::cloudflare::ZoneTimeBucket_Counter > map_entry_;
  friend void  protobuf_AddDesc_entry_2eproto();
  friend void protobuf_AssignDesc_entry_2eproto();
  friend void protobuf_ShutdownFile_entry_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(10 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static ZoneTimeBucket* default_instance_;
};
// ===================================================================


// ===================================================================

// ZoneTimeBucket_Counter

// required string key = 1;
inline bool ZoneTimeBucket_Counter::has_key() const {
  return _has_bit(0);
}
inline void ZoneTimeBucket_Counter::clear_key() {
  if (key_ != &_default_key_) {
    key_->clear();
  }
  _clear_bit(0);
}
inline const ::std::string& ZoneTimeBucket_Counter::key() const {
  return *key_;
}
inline void ZoneTimeBucket_Counter::set_key(const ::std::string& value) {
  _set_bit(0);
  if (key_ == &_default_key_) {
    key_ = new ::std::string;
  }
  key_->assign(value);
}
inline void ZoneTimeBucket_Counter::set_key(const char* value) {
  _set_bit(0);
  if (key_ == &_default_key_) {
    key_ = new ::std::string;
  }
  key_->assign(value);
}
inline void ZoneTimeBucket_Counter::set_key(const char* value, size_t size) {
  _set_bit(0);
  if (key_ == &_default_key_) {
    key_ = new ::std::string;
  }
  key_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ZoneTimeBucket_Counter::mutable_key() {
  _set_bit(0);
  if (key_ == &_default_key_) {
    key_ = new ::std::string;
  }
  return key_;
}

// required int64 value = 2;
inline bool ZoneTimeBucket_Counter::has_value() const {
  return _has_bit(1);
}
inline void ZoneTimeBucket_Counter::clear_value() {
  value_ = GOOGLE_LONGLONG(0);
  _clear_bit(1);
}
inline ::google::protobuf::int64 ZoneTimeBucket_Counter::value() const {
  return value_;
}
inline void ZoneTimeBucket_Counter::set_value(::google::protobuf::int64 value) {
  _set_bit(1);
  value_ = value;
}

// -------------------------------------------------------------------

// ZoneTimeBucket

// required string map_name = 1;
inline bool ZoneTimeBucket::has_map_name() const {
  return _has_bit(0);
}
inline void ZoneTimeBucket::clear_map_name() {
  if (map_name_ != &_default_map_name_) {
    map_name_->clear();
  }
  _clear_bit(0);
}
inline const ::std::string& ZoneTimeBucket::map_name() const {
  return *map_name_;
}
inline void ZoneTimeBucket::set_map_name(const ::std::string& value) {
  _set_bit(0);
  if (map_name_ == &_default_map_name_) {
    map_name_ = new ::std::string;
  }
  map_name_->assign(value);
}
inline void ZoneTimeBucket::set_map_name(const char* value) {
  _set_bit(0);
  if (map_name_ == &_default_map_name_) {
    map_name_ = new ::std::string;
  }
  map_name_->assign(value);
}
inline void ZoneTimeBucket::set_map_name(const char* value, size_t size) {
  _set_bit(0);
  if (map_name_ == &_default_map_name_) {
    map_name_ = new ::std::string;
  }
  map_name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ZoneTimeBucket::mutable_map_name() {
  _set_bit(0);
  if (map_name_ == &_default_map_name_) {
    map_name_ = new ::std::string;
  }
  return map_name_;
}

// required string classification = 2;
inline bool ZoneTimeBucket::has_classification() const {
  return _has_bit(1);
}
inline void ZoneTimeBucket::clear_classification() {
  if (classification_ != &_default_classification_) {
    classification_->clear();
  }
  _clear_bit(1);
}
inline const ::std::string& ZoneTimeBucket::classification() const {
  return *classification_;
}
inline void ZoneTimeBucket::set_classification(const ::std::string& value) {
  _set_bit(1);
  if (classification_ == &_default_classification_) {
    classification_ = new ::std::string;
  }
  classification_->assign(value);
}
inline void ZoneTimeBucket::set_classification(const char* value) {
  _set_bit(1);
  if (classification_ == &_default_classification_) {
    classification_ = new ::std::string;
  }
  classification_->assign(value);
}
inline void ZoneTimeBucket::set_classification(const char* value, size_t size) {
  _set_bit(1);
  if (classification_ == &_default_classification_) {
    classification_ = new ::std::string;
  }
  classification_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ZoneTimeBucket::mutable_classification() {
  _set_bit(1);
  if (classification_ == &_default_classification_) {
    classification_ = new ::std::string;
  }
  return classification_;
}

// required string doctype = 3;
inline bool ZoneTimeBucket::has_doctype() const {
  return _has_bit(2);
}
inline void ZoneTimeBucket::clear_doctype() {
  if (doctype_ != &_default_doctype_) {
    doctype_->clear();
  }
  _clear_bit(2);
}
inline const ::std::string& ZoneTimeBucket::doctype() const {
  return *doctype_;
}
inline void ZoneTimeBucket::set_doctype(const ::std::string& value) {
  _set_bit(2);
  if (doctype_ == &_default_doctype_) {
    doctype_ = new ::std::string;
  }
  doctype_->assign(value);
}
inline void ZoneTimeBucket::set_doctype(const char* value) {
  _set_bit(2);
  if (doctype_ == &_default_doctype_) {
    doctype_ = new ::std::string;
  }
  doctype_->assign(value);
}
inline void ZoneTimeBucket::set_doctype(const char* value, size_t size) {
  _set_bit(2);
  if (doctype_ == &_default_doctype_) {
    doctype_ = new ::std::string;
  }
  doctype_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ZoneTimeBucket::mutable_doctype() {
  _set_bit(2);
  if (doctype_ == &_default_doctype_) {
    doctype_ = new ::std::string;
  }
  return doctype_;
}

// required string pop = 4;
inline bool ZoneTimeBucket::has_pop() const {
  return _has_bit(3);
}
inline void ZoneTimeBucket::clear_pop() {
  if (pop_ != &_default_pop_) {
    pop_->clear();
  }
  _clear_bit(3);
}
inline const ::std::string& ZoneTimeBucket::pop() const {
  return *pop_;
}
inline void ZoneTimeBucket::set_pop(const ::std::string& value) {
  _set_bit(3);
  if (pop_ == &_default_pop_) {
    pop_ = new ::std::string;
  }
  pop_->assign(value);
}
inline void ZoneTimeBucket::set_pop(const char* value) {
  _set_bit(3);
  if (pop_ == &_default_pop_) {
    pop_ = new ::std::string;
  }
  pop_->assign(value);
}
inline void ZoneTimeBucket::set_pop(const char* value, size_t size) {
  _set_bit(3);
  if (pop_ == &_default_pop_) {
    pop_ = new ::std::string;
  }
  pop_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ZoneTimeBucket::mutable_pop() {
  _set_bit(3);
  if (pop_ == &_default_pop_) {
    pop_ = new ::std::string;
  }
  return pop_;
}

// required string psource = 5;
inline bool ZoneTimeBucket::has_psource() const {
  return _has_bit(4);
}
inline void ZoneTimeBucket::clear_psource() {
  if (psource_ != &_default_psource_) {
    psource_->clear();
  }
  _clear_bit(4);
}
inline const ::std::string& ZoneTimeBucket::psource() const {
  return *psource_;
}
inline void ZoneTimeBucket::set_psource(const ::std::string& value) {
  _set_bit(4);
  if (psource_ == &_default_psource_) {
    psource_ = new ::std::string;
  }
  psource_->assign(value);
}
inline void ZoneTimeBucket::set_psource(const char* value) {
  _set_bit(4);
  if (psource_ == &_default_psource_) {
    psource_ = new ::std::string;
  }
  psource_->assign(value);
}
inline void ZoneTimeBucket::set_psource(const char* value, size_t size) {
  _set_bit(4);
  if (psource_ == &_default_psource_) {
    psource_ = new ::std::string;
  }
  psource_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ZoneTimeBucket::mutable_psource() {
  _set_bit(4);
  if (psource_ == &_default_psource_) {
    psource_ = new ::std::string;
  }
  return psource_;
}

// required string result_id = 6;
inline bool ZoneTimeBucket::has_result_id() const {
  return _has_bit(5);
}
inline void ZoneTimeBucket::clear_result_id() {
  if (result_id_ != &_default_result_id_) {
    result_id_->clear();
  }
  _clear_bit(5);
}
inline const ::std::string& ZoneTimeBucket::result_id() const {
  return *result_id_;
}
inline void ZoneTimeBucket::set_result_id(const ::std::string& value) {
  _set_bit(5);
  if (result_id_ == &_default_result_id_) {
    result_id_ = new ::std::string;
  }
  result_id_->assign(value);
}
inline void ZoneTimeBucket::set_result_id(const char* value) {
  _set_bit(5);
  if (result_id_ == &_default_result_id_) {
    result_id_ = new ::std::string;
  }
  result_id_->assign(value);
}
inline void ZoneTimeBucket::set_result_id(const char* value, size_t size) {
  _set_bit(5);
  if (result_id_ == &_default_result_id_) {
    result_id_ = new ::std::string;
  }
  result_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ZoneTimeBucket::mutable_result_id() {
  _set_bit(5);
  if (result_id_ == &_default_result_id_) {
    result_id_ = new ::std::string;
  }
  return result_id_;
}

// required string db_key = 7;
inline bool ZoneTimeBucket::has_db_key() const {
  return _has_bit(6);
}
inline void ZoneTimeBucket::clear_db_key() {
  if (db_key_ != &_default_db_key_) {
    db_key_->clear();
  }
  _clear_bit(6);
}
inline const ::std::string& ZoneTimeBucket::db_key() const {
  return *db_key_;
}
inline void ZoneTimeBucket::set_db_key(const ::std::string& value) {
  _set_bit(6);
  if (db_key_ == &_default_db_key_) {
    db_key_ = new ::std::string;
  }
  db_key_->assign(value);
}
inline void ZoneTimeBucket::set_db_key(const char* value) {
  _set_bit(6);
  if (db_key_ == &_default_db_key_) {
    db_key_ = new ::std::string;
  }
  db_key_->assign(value);
}
inline void ZoneTimeBucket::set_db_key(const char* value, size_t size) {
  _set_bit(6);
  if (db_key_ == &_default_db_key_) {
    db_key_ = new ::std::string;
  }
  db_key_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ZoneTimeBucket::mutable_db_key() {
  _set_bit(6);
  if (db_key_ == &_default_db_key_) {
    db_key_ = new ::std::string;
  }
  return db_key_;
}

// required string db_path = 8;
inline bool ZoneTimeBucket::has_db_path() const {
  return _has_bit(7);
}
inline void ZoneTimeBucket::clear_db_path() {
  if (db_path_ != &_default_db_path_) {
    db_path_->clear();
  }
  _clear_bit(7);
}
inline const ::std::string& ZoneTimeBucket::db_path() const {
  return *db_path_;
}
inline void ZoneTimeBucket::set_db_path(const ::std::string& value) {
  _set_bit(7);
  if (db_path_ == &_default_db_path_) {
    db_path_ = new ::std::string;
  }
  db_path_->assign(value);
}
inline void ZoneTimeBucket::set_db_path(const char* value) {
  _set_bit(7);
  if (db_path_ == &_default_db_path_) {
    db_path_ = new ::std::string;
  }
  db_path_->assign(value);
}
inline void ZoneTimeBucket::set_db_path(const char* value, size_t size) {
  _set_bit(7);
  if (db_path_ == &_default_db_path_) {
    db_path_ = new ::std::string;
  }
  db_path_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ZoneTimeBucket::mutable_db_path() {
  _set_bit(7);
  if (db_path_ == &_default_db_path_) {
    db_path_ = new ::std::string;
  }
  return db_path_;
}

// optional string kv_map_file = 9;
inline bool ZoneTimeBucket::has_kv_map_file() const {
  return _has_bit(8);
}
inline void ZoneTimeBucket::clear_kv_map_file() {
  if (kv_map_file_ != &_default_kv_map_file_) {
    kv_map_file_->clear();
  }
  _clear_bit(8);
}
inline const ::std::string& ZoneTimeBucket::kv_map_file() const {
  return *kv_map_file_;
}
inline void ZoneTimeBucket::set_kv_map_file(const ::std::string& value) {
  _set_bit(8);
  if (kv_map_file_ == &_default_kv_map_file_) {
    kv_map_file_ = new ::std::string;
  }
  kv_map_file_->assign(value);
}
inline void ZoneTimeBucket::set_kv_map_file(const char* value) {
  _set_bit(8);
  if (kv_map_file_ == &_default_kv_map_file_) {
    kv_map_file_ = new ::std::string;
  }
  kv_map_file_->assign(value);
}
inline void ZoneTimeBucket::set_kv_map_file(const char* value, size_t size) {
  _set_bit(8);
  if (kv_map_file_ == &_default_kv_map_file_) {
    kv_map_file_ = new ::std::string;
  }
  kv_map_file_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ZoneTimeBucket::mutable_kv_map_file() {
  _set_bit(8);
  if (kv_map_file_ == &_default_kv_map_file_) {
    kv_map_file_ = new ::std::string;
  }
  return kv_map_file_;
}

// repeated .cloudflare.ZoneTimeBucket.Counter map_entry = 10;
inline int ZoneTimeBucket::map_entry_size() const {
  return map_entry_.size();
}
inline void ZoneTimeBucket::clear_map_entry() {
  map_entry_.Clear();
}
inline const ::cloudflare::ZoneTimeBucket_Counter& ZoneTimeBucket::map_entry(int index) const {
  return map_entry_.Get(index);
}
inline ::cloudflare::ZoneTimeBucket_Counter* ZoneTimeBucket::mutable_map_entry(int index) {
  return map_entry_.Mutable(index);
}
inline ::cloudflare::ZoneTimeBucket_Counter* ZoneTimeBucket::add_map_entry() {
  return map_entry_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::cloudflare::ZoneTimeBucket_Counter >&
ZoneTimeBucket::map_entry() const {
  return map_entry_;
}
inline ::google::protobuf::RepeatedPtrField< ::cloudflare::ZoneTimeBucket_Counter >*
ZoneTimeBucket::mutable_map_entry() {
  return &map_entry_;
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace cloudflare

#ifndef SWIG
namespace google {
namespace protobuf {


}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_entry_2eproto__INCLUDED
